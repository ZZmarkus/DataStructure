#pragma warning (disable : 4996)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "sqlite3.h"
#define CL_SIZE 26;

// 원형 연결 리스트의 노드 구조를 구조체로 정의
typedef struct ListNode {
	int id;
	char data[15];
	int searchNum = 0;
	struct ListNode* link;
} listNode;

struct ListNode* p[1000];
int structCnt = 0;

// 리스트의 시작을 나타내는 head 노드를 구조체로 정의
typedef struct {
	listNode* head;
} linkedList_h;


// 공백 원형 연결 리스트를 생성하는 연산
linkedList_h* createLinkedList_h(void) {
	linkedList_h* CL;
	CL = (linkedList_h*)malloc(sizeof(linkedList_h));	// 헤드 노드 할당
	CL->head = NULL;										// 공백 리스트이므로 NULL로 설정
	return CL;
}

// 연결 리스트를 순서대로 출력하는 연산
void printList(linkedList_h* CL) {
	listNode* p;
	printf(" CL = (");
	p = CL->head;
	do {
		printf("%s", p->data);
		p = p->link;
		if (p != CL->head) printf(", ");
	} while (p != CL->head);
	printf(") \n");
}

// 첫 번째 노드 삽입 연산
void insertFirstNode(linkedList_h *CL, char* x) {
	listNode* newNode, *temp;
	newNode = (listNode*)malloc(sizeof(listNode));	// 삽입할 새 노드 할당
	strcpy(newNode->data, x);
	if (CL->head == NULL) {		// 원형 연결 리스트가 공백인 경우	
		CL->head = newNode;		// 새 노드를 리스트의 시작 노드로 연결
		newNode->link = newNode;
	}
	else {						// 원형 연결 리스트가 공백이 아닌 경우 	
		temp = CL->head;
		while (temp->link != CL->head)
			temp = temp->link;
		newNode->link = temp->link;
		temp->link = newNode;	// 마지막 노드를 첫 번째 노드인 new와 원형 연결 
		CL->head = newNode;
	}
}

// pre 뒤에 노드를 삽입하는 연산
void insertMiddleNode(linkedList_h* CL, listNode *pre, char* x) {
	listNode* newNode;
	newNode = (listNode*)malloc(sizeof(listNode));
	strcpy(newNode->data, x);
	if (CL == NULL) {
		CL->head = newNode;
		newNode->link = newNode;
	}
	else if (pre == NULL)		//탐색한 것이 없을때 즉 pre가 NULL일 경우도 추가하였음
	{
		return;
	}
	else {
		newNode->link = pre->link;
		pre->link = newNode;
	}
}

// 원형 연결 리스트의 pre 뒤에 있는 노드 old를 삭제하는 연산
void deleteNode(linkedList_h* CL, listNode* old) {
	listNode* pre;					// 삭제할 노드의 선행자 노드를 나타내는 포인터	
	if (CL->head == NULL) return;	// 공백 리스트인 경우, 삭제 연산 중단	
	if (CL->head->link == NULL) {	// 리스트에 노드가 한 개만 있는 경우
		free(CL->head);				// 첫 번째 노드의 메모리를 해제하고
		CL->head = NULL;				// 리스트 시작 포인터를 NULL로 설정
		return;
	}
	else if (old == NULL) return;   // 삭제할 노드가 없는 경우, 삭제 연산 중단	
	else {
		pre = CL->head;				// 포인터 pre를 리스트의 시작 노드에 연결		
		while (pre->link != old) {
			pre = pre->link;			// 선행자 노드를 포인터 pre를 이용해 찾음
		}
		pre->link = old->link;
		if (old == CL->head)
			CL->head = old->link;
		free(old);					// 삭제 노드의 메모리를 해제	 		
	}
}

// 원형 연결 리스트에서 x 노드를 탐색하는 연산
listNode* searchNode(linkedList_h* CL, char* x) {
	listNode *temp;
	temp = CL->head;

	if (strcmp(temp->data, x) == 0) //처음에 temp!=NULL이었는데 만약 찾는 노드가 없다면 무한반복이 되기때문에 코드를 수정함
		return temp;
	else temp = temp->link;

	while (temp != CL->head) {
		if (strcmp(temp->data, x) == 0) return temp;
		else temp = temp->link;
	}
	temp = NULL;
	return temp;	//찾는값이 없을경우 NULL반환
}

void Input(FILE* fp1);
void Input2(FILE* fp1);

int main()
{
	FILE* fp;
	linkedList_h* CL;
	CL = createLinkedList_h();
	ListNode* ptr;
	char alpha[10] = "a";
	insertFirstNode(CL, alpha);
	for (int i = 1; i < CL_SIZE i++)
	{
		ptr = searchNode(CL, alpha);
		alpha[0] = alpha[0] + 1;
		insertMiddleNode(CL, ptr, alpha);
	}
	int chose;
	printf("(주의)1번을 택한 후 열린 메모장의 알파벳을 검색 해 주세요\n");
	while (true)
	{
		printf("1. 랜덤으로 단어장 열기 2. 단어 검색하기\n");
		scanf("%d", &chose);
		if (chose == 1)
		{
			srand((unsigned)time(NULL));
			int y;
			y = rand();
			y = rand() % CL_SIZE;
			char note[20] = "notepad.exe ";
			char txt[10] = ".txt";
			char alp1[2] = "a";
			char alp2[2] = "a";
			alp1[0] = alp1[0] + y;
			alp2[0] = alp2[0] + y;
			strcat(note, alp1);
			strcat(note, txt);
			system(note);

			strcat(alp2, ".txt");
			fp = fopen(alp2, "at+");
			Input(fp);
			fclose(fp);
		}
		else if (chose == 2)
		{
			int searchNum = 0;
			int id;
			int num;
			char tmp[15];
			char search[15];
			printf("검색할 단어를 입력해 주세요 :");
			scanf("%s", search);
			char a[10];
			a[0] = search[0];
			a[1] = '\0';
			strcat(a, ".txt");
			fp = fopen(a, "at+");
			Input2(fp);
			for (int i = 0; i <=structCnt; i++)
			{
				fscanf(fp, "%d %s", &id, tmp);
				if (i == structCnt)
				{
					fprintf(fp, "\n%02d %s", structCnt+1, search);
				}
				else if (strcmp(tmp, search) == 0)
				{
					p[i]->searchNum += 1;
					printf("\n %s의 단어를 검색한 횟수 : %d \n", search, p[i]->searchNum);
				}
			}
			
			fclose(fp);
		}
	}
	system("pause");
}

void Input(FILE* fp1)
{
	FILE* fp2;
	fp2 = fopen("allAlpha.txt", "at+");
	int id;
	char alphabet[15];
	structCnt = 0;

	while (!feof(fp1))
	{
		p[structCnt] = (ListNode*)malloc(sizeof(ListNode));
		fscanf(fp1, "%d %s", &id, alphabet);
		p[structCnt]->id = id;
		strcpy(p[structCnt]->data, alphabet);
		p[structCnt]->searchNum = 0;
		fprintf(fp2, "%d %s\n", p[structCnt]->id, p[structCnt]->data);
		fprintf(stdout, "%02d %s\n", p[structCnt]->id, p[structCnt]->data);
		structCnt++;
	}
	fprintf(fp2, "단어의 개수 : %d\n", structCnt);
	fprintf(stdout, "단어의 개수 : %d\n", structCnt);
	fprintf(fp2, "-----------------------\n");
	fclose(fp2);
	printf("---------------------------\n");
}

void Input2(FILE* fp1)
{
	int id;
	char alphabet[15];
	structCnt = 0;

	while (!feof(fp1))
	{
		p[structCnt] = (ListNode*)malloc(sizeof(ListNode));
		fscanf(fp1, "%d %s", &id, alphabet);
		p[structCnt]->id = id;
		strcpy(p[structCnt]->data, alphabet);
		p[structCnt]->searchNum = 0;
		structCnt++;
	}
}